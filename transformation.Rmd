```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# Data Transformation

The goal of this section is to continue where we started in the earlier chapter on data abstraction with **`dplyr`** to look at the more transformational functions applied to data in a database, and **`tidyr`** adds other tools like pivot tables.

- **`dplyr`** tools: 
   - joins: `left_join`, `right_join`, `inner_join`, `full_join`, `semi_join`, `anti_join`
   - set operations: `intersect`, `union`, `setdiff`
   - binding rows and columns: `bind_cols`, `bind_rows`
- **`tidyr`** tools:
   - pivot tables: `pivot_longer`, `pivot_wider`
   

The term "data wrangling" has been used for what we're doing with these tools, and the
relevant cheat sheet is actually called "Data Wrangling"
<a href="https://rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf">https://rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf</a>

## Data joins

To bring in variables from another data frame based on a common join field.
There are multiple types of joins. Probably the most common is **`left_join`** since it starts
from the data frame (or sf) you want to continue working with and bring in data
from an additional source. You'll retain all records of the first data set. 
For any non-matches, NA is assigned. [**`air_quality`**]

```{r message=F, warning=F}
library(tidyverse)
library(iGIScData)
library(sf)
csvPath <- system.file("extdata", "CA_MdInc.csv", package = "iGIScData")
income <- read_csv(csvPath) %>%
   dplyr::select(trID, HHinc2016) %>%
   mutate(HHinc2016 = as.numeric(HHinc2016),
          joinid = str_c("0", trID)) %>%
   dplyr::select(joinid, HHinc2016)
census <- BayAreaTracts %>%
   left_join(income, by = c("FIPS" = "joinid")) %>%
   dplyr::select(FIPS, POP12_SQMI, POP2012, HHinc2016)
head(census %>% st_set_geometry(NULL))
```

Other joins are:

- **`right_join`** where you end up retaining all the rows of the second data set
and NA is assigned to non-matches
- **`inner_join`** where you only retain records for matches
- **`full_join`** where records are retained for both sides, and NAs assigned to non-matches

**Right join example**
We need to join NCDC monthly climate data for all California weather stations to a selection of 82 stations that are in the Sierra. 

- The monthly data has 12 rows (1/month) for each station
- The right_join gets all months for all stations, so we weed out the non-Sierra stations by removing NAs from a field only with Sierra station data [**`sierra`**]

```{r message=F}
sierra <- right_join(sierraStations, CA_ClimateNormals, by="STATION") %>%
   filter(!is.na(STATION_NA)) %>% dplyr::select(-STATION_NA)
head(sierra %>% filter(DATE == "01") %>% dplyr::select(NAME, ELEVATION, `MLY-TAVG-NORMAL`), n=10)
```

The exact same thing however could be accomplished with an inner_join and
it doesn't required removing the NAs:

```{r message=F}
sierraAlso <- inner_join(sierraStations, CA_ClimateNormals, by="STATION") %>%
   dplyr::select(-STATION_NA)
```

## Set Operations

Set operations compare two data frames (or vectors) to handle observations or rows that 
are the same for each, or not the same. The three set methods are:

- `dplyr::`**`intersect(x,y)`** retains rows that appear in *both* x and y
- `dplyr::`**`union(x,y)`** retains rows that appear in either or both of x and y
- `dplyr::`**`setdiff(x,y)`** retains rows that appear in x but not in y

[**`generic_methods`**]
```{r message=F}
squares <- (1:10)^2
evens <- seq(0,100,2)
squares
evens
intersect(squares,evens)
sort(union(squares,evens))
sort(setdiff(squares,evens))
```

## Binding Rows and Columns

These `dplyr` functions are similar to `cbind` and `rbind` in base R, but always 
creates data frames. For instance, `cbind` usually creates matrices, and make all vectors
the same class. Note that in `bind_cols`, the order of data in rows must be the same.

```{r message=F}
states <- bind_cols(abb=state.abb,
                    name=state.name,
                    region=state.region,
                    state.x77)
head(states)
```

To compare, note that `cbind` converts numeric fields to character when any other 
field is character, and character fields are converted to character integers where there are any repeats, 
which would require manipulating them into factors:

```{r message=F}
states <- as_tibble(cbind(abb=state.abb, 
                          name=state.name, 
                          region=state.region,
                          division=state.division,
                          state.x77))
head(states)
```

## Pivotting data frames

Pivot tables are a popular tool in Excel, allowing you to transform your data to be more
useful in a particular analysis. A common need to pivot is 2+ variables with the same data where the variable name should be a factor. `Tidyr` has **`pivot_wider`** and **`pivot_longer`**.  

- **`pivot_wider`** pivots rows into variables.
- **`pivot_longer`** pivots variables into rows, creating factors.

In our meadows study cross-section [@NDVI] created by intersecting normalized difference vegetation index (NDVI) values from multispectral drone imagery with surveyed elevation and vegetation types (xeric, mesic, and hydric), we have fields `NDVIgrowing` from a July 2019 growing season and `NDVIsenescent` from a September 2020 dry season, but would like 'growing' and 'senescent' to be factors with a single `NDVI` variable. This is how we used `pivot_longer` to accomplish this, using data from the `iGIScData` data package [**`NDVI`**]:

```{r message=F}
XSptsPheno <- XSptsNDVI %>%
      pivot_longer(cols = starts_with("NDVI"), 
                   names_to = "phenology", values_to = "NDVI") %>%
      mutate(phenology = str_sub(phenology, 5, str_length(phenology)))
```

Then to do the opposite use `pivot_wider`:

```{r message=F}
XSptsPheno %>%
  pivot_wider(names_from = phenology, names_prefix = "NDVI", 
              values_from = NDVI)
XSptsPheno
XSptsPheno %>%
  ggplot() +
  geom_point(aes(elevation, NDVI, shape=vegetation, 
                 color = phenology), size = 5) +
  geom_smooth(aes(elevation, NDVI, 
                 color = phenology), method="lm")
```

Pivots turn out to be commonly useful. Runoff graphing from the Eucalyptus/Oak study [@eucoak] also benefited
from a pivot_longer [**`eucoak`**]:

```{r message=F, warning=F}
eucoakrainfallrunoffTDR %>%
  pivot_longer(cols = starts_with("runoffL"),
               names_to = "tree", values_to = "runoffL") %>%
  mutate(tree = str_sub(tree, str_length(tree)-2, str_length(tree))) %>%
  ggplot() + geom_boxplot(aes(site, runoffL)) +
    facet_grid(tree ~ .)
```

**Combining a pivot with bind_rows to create a runoff/rainfall scatterplot colored by tree**

```{r message=F, warning=F}
runoffPivot <- eucoakrainfallrunoffTDR %>%
  pivot_longer(cols = starts_with("runoffL"),
               names_to = "tree", values_to = "runoffL") %>%
  mutate(tree = str_sub(tree, str_length(tree)-2, str_length(tree)),
         Date = as.Date(date, "%m/%d/%Y"))
euc <- runoffPivot %>%
  filter(tree == "euc") %>%
  mutate(rain_subcanopy = rain_euc,
         slope = slope_euc,    aspect = aspect_euc,
         surface_tension = surface_tension_euc,
         runoff_rainfall_ratio = runoff_rainfall_ratio_euc) %>%
  dplyr::select(site, `site #`, tree, Date, month, rain_mm, 
         rain_subcanopy, slope, aspect, runoffL,     
         surface_tension, runoff_rainfall_ratio)
oak <- runoffPivot %>%
  filter(tree == "oak") %>%
  mutate(rain_subcanopy = rain_oak,
         slope = slope_oak, aspect = aspect_oak,
         surface_tension = surface_tension_oak,
         runoff_rainfall_ratio = runoff_rainfall_ratio_oak) %>%
  dplyr::select(site, `site #`, tree, Date, month, rain_mm, 
         rain_subcanopy, slope, aspect, runoffL, 
         surface_tension, runoff_rainfall_ratio)
bind_rows(euc, oak) %>%
  ggplot() +
  geom_point(mapping = aes(x = rain_mm, y = runoffL, color = tree)) +
  geom_smooth(mapping = aes(x = rain_mm, y= runoffL, color = tree), 
              method = "lm") +
  scale_color_manual(values = c("seagreen4", "orange3"))
```

**Using pivot_wider with traffic stop data** [@Engel]

```{r message=F}
library(lubridate)
csvPath <- system.file("extdata","MS_trafficstops_bw_age.csv", package="iGIScData")
trafficStops <- read_csv(csvPath) %>%
  mutate(year = year(stop_date))
trafficCounts <- trafficStops %>%
  count(year,violation_raw)
trafficCounts %>%
  pivot_wider(names_from = year, 
              values_from = n)

```

Note that this table is *not* tidy, but provides a useful table for a report.

## Data wrangling exercise
*by Josh von Nonn (2021)*

The impetus behind this exercise is from the movie Dark Waters (https://www.youtube.com/watch?v=RvAOuhyunhY), inspired by a true story of negligent chemical waste disposal by Dupont.

First create a new RStudio project, named `GAMA` and save this .Rmd file there, and create a folder `GAMA_water_data` in the project folder; the path to the data can then be specified as `"GAMA_water_data/gama_pfas_statewide_v2.txt"` assuming that the latter name matches what is unzipped from your download.

Then download from the California Water Boards, GAMA groundwater website. 
[https://gamagroundwater.waterboards.ca.gov/gama/datadownload]


Then select "Statewide Downloads" then "Statewide PFOS Data" and extract the zip file into a folder "" located in your project folder. Remember this path. This is a large txt file so if you open it with notepad it may take some time to load. Notice that this is a space delimited file.

Required packages:
```{r}
library(tidyverse)
library(lubridate)
```

Read in the downloaded file "gama_pfas_statewide_v2.txt" and call it cal_pfas and have a look at the data set. You can select if from the Envronment pane or use view(cal_pfas).
```{r include=F}
cal_pfas <- read.delim("GAMA_water_data\\gama_pfas_statewide_v2.txt")

```
Before we clean up this data, let's preserve the locations of all the wells. Select GM_WELL_ID, GM_LATITUDE, and GM_LONGITUDE and remove all the duplicate wells (hint: dplyr cheat sheet provides a function to do this) and save this as cal_pfas_loc.
```{r include=F}
#retaining a small data frame for well geolocations
cal_pfas_loc <- select(cal_pfas,GM_WELL_ID,lat = GM_LATITUDE,long = GM_LONGITUDE) %>%
  distinct() #removes duplicate wells
```
Now to trim down the data. Create a new data frame- cal_pfas_trim; add a new column, DATE, using the associated lubridate function on GM_SAMP_COLLECTION_DATE (this will allow ggplot to recognize it as a date and not a character string), select GM_WELL_ID,GM_CHEMICAL_VVL,GM_RESULT, and the newly created DATE. Arrange the data by GM_WELL_ID.
```{r include=F}
#cleaning up cal_pfas
cal_pfas_trim <- cal_pfas %>%
  mutate(DATE=mdy(GM_SAMP_COLLECTION_DATE)) %>% #using lubridate(mdy) for ggplot communication
  select(GM_WELL_ID,GM_CHEMICAL_VVL,GM_RESULT,DATE) %>% 
  arrange(GM_WELL_ID) #arrange used here to aid in visualizing data frame
```
Pivot the data to create new columns from the chemical names and values from the result column and store the new data frame as cal_pfas_wide. Notice the warnings. Some of the wells have multiple samples on the same day so they will be put into a list (ex. c(6.8,9,4.3,etc..)). Rerun the pivot but include the argument- values_fn = mean. This will return only the average of all the samples. Once the pivot is working correctly, keep the columns GM_WELL_ID,DATE,PFOS,PFOA and pipe a mutate to create a new column SUMPFS that is the sum of PFOS +  PFOA.
```{r include=F}
#pivoting wider, "values_fn" is used here to average the multiple per-day results, otherwise the values would be a list ex, c(4.8,6.8,etc.)
cal_pfas_wide <- pivot_wider(cal_pfas_trim,names_from = "GM_CHEMICAL_VVL",values_from = "GM_RESULT", values_fn = mean) %>%
  select(GM_WELL_ID,DATE,PFOS,PFOA) %>%
  mutate(SUMPFS= PFOS + PFOA) #creating a new column for the sum of PFOS + PFOA 

#"The US EPA has established a lifetime Health Advisory Level (HAL) for PFOA and PFOS of
#70 ng/L. When both PFOA and PFOS are found in drinking water, the combined
#concentrations of PFOA and PFOS should be compared with the 70 ng/L HAL." from GROUNDWATER INFORMATION SHEET
```
"The US EPA has established a lifetime Health Advisory Level (HAL) for PFOA and PFOS of 70 ng/L. When both PFOA and PFOS are found in drinking water, the combined concentrations of PFOA and PFOS should be compared with the 70 ng/L HAL."- from the GROUNDWATER INFORMATION SHEET for PFOA (website:https://www.waterboards.ca.gov/water_issues/programs/gama/factsheets.html)

For the sake of creating an interesting time series plot, lets filter data for wells that have a SUMPFS greater than 70 and that have more than 10 sampling dates. Start by creating a new data frame- cal_pfas_index from the pivoted data frame. Hint: use goup_by, filter, count, and filter again. The resulting data frame should have 11 observations and 2 variables.
```{r include=F}
#creating an index by filtering for PFOS_PFOA greater than 70(HAL) with more than 10 sample dates.
#We're choosing for wells with an extended sampling history to plot a time series later.
cal_pfas_index <- cal_pfas_wide %>%
  group_by(GM_WELL_ID) %>% #group_by function is needed here for count to work properly
  filter(SUMPFS > 70) %>%
  count() %>%
  filter(n>10)
```
Locate the well with the most sampling dates (n). The data wrangling function from Rbase, subset, can do this adding the max function as an argument. 
```{r include=F}
#locating the longest sampled well with PFOS_PFOA greater than 70. Note that this is not the well with the highest concentrations, but one with a long sampling history. 
cal_pfas_max <- subset(cal_pfas_index,n==max(n))
```
Lastly, let's pull all the data on that well by joining the max indexed well to cal_pfas_wide. Remove the "n" column using the select function.
```{r include=F}
cal_pfas_join <- left_join(cal_pfas_max,cal_pfas_wide,by="GM_WELL_ID") %>%
  select(-n)
```
Plot the well with ggplot, using DATE on the x axis and plot the three variables (PFOS,PFOA,SUMPFS) with different colors. Add a horizontal reference line for the HAL limit at 70.
```{r echo=F}
#use ggplot to visualize set HAL level with a horizontal line at 70
ggplot(cal_pfas_join, aes(x=DATE)) +
  geom_line(aes(y=PFOS),color = "darkred") +
  geom_line(aes(y=PFOA),color="steelblue") +
  geom_line(aes(y=SUMPFS), color="purple") +
  geom_hline(yintercept = 70)
```



